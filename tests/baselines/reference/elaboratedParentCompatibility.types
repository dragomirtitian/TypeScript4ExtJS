=== tests/cases/compiler/elaboratedParentCompatibility.ts ===
interface Person {
    residence: House;
>residence : House
}

interface House {
    isHouseOfPain: boolean;
>isHouseOfPain : boolean
}

declare let home: House;
>home : House

declare let person: Person; 
>person : Person

home = person.residence.isHouseOfPain; 
>home = person.residence.isHouseOfPain : boolean
>home : House
>person.residence.isHouseOfPain : boolean
>person.residence : House
>person : Person
>residence : House
>isHouseOfPain : boolean

declare function fnHouse(home: House): void;
>fnHouse : (home: House) => void
>home : House

fnHouse(person.residence.isHouseOfPain) // Suggest person.residence
>fnHouse(person.residence.isHouseOfPain) : void
>fnHouse : (home: House) => void
>person.residence.isHouseOfPain : boolean
>person.residence : House
>person : Person
>residence : House
>isHouseOfPain : boolean

fnHouse((person.residence).isHouseOfPain) // Suggest person.residence
>fnHouse((person.residence).isHouseOfPain) : void
>fnHouse : (home: House) => void
>(person.residence).isHouseOfPain : boolean
>(person.residence) : House
>person.residence : House
>person : Person
>residence : House
>isHouseOfPain : boolean

fnHouse(person["residence"].isHouseOfPain) // No suggestion here only suggest on dotted access
>fnHouse(person["residence"].isHouseOfPain) : void
>fnHouse : (home: House) => void
>person["residence"].isHouseOfPain : boolean
>person["residence"] : House
>person : Person
>"residence" : "residence"
>isHouseOfPain : boolean

enum W { A, B, C }
>W : W
>A : W.A
>B : W.B
>C : W.C

let wStatic: typeof W = W.A; // Suggest W
>wStatic : typeof W
>W : typeof W
>W.A : W.A
>W : typeof W
>A : W.A

class C {
>C : C

    name: string;
>name : string

    method (): C {
>method : () => C

        let c: C = this.name; // Suggest this
>c : C
>this.name : string
>this : this
>name : string

        return c;
>c : C
    }
}

declare function getC(): C;
>getC : () => C

let cInstance:C = getC().name // No suggestion
>cInstance : C
>getC().name : string
>getC() : C
>getC : () => C
>name : string

let cInstance2:C = cInstance.name //Suggest cInstance
>cInstance2 : C
>cInstance.name : string
>cInstance : C
>name : string

interface X { x: string }
>x : string

interface Y { y: number }
>y : number

interface Z { z?: boolean }
>z : boolean | undefined

type XY = X & Y;
>XY : XY

const xy: XY = {x: 'x', y: 10};
>xy : XY
>{x: 'x', y: 10} : { x: string; y: number; }
>x : string
>'x' : "x"
>y : number
>10 : 10

const z1: Z = xy; // error, {xy} doesn't overlap with {z}
>z1 : Z
>xy : XY


interface ViewStyle {
    view: number
>view : number

    styleMedia: string
>styleMedia : string
}
type Brand<T> = number & { __brand: T }
>Brand : Brand<T>
>__brand : T

declare function create<T extends { [s: string]: ViewStyle }>(styles: T): { [P in keyof T]: Brand<T[P]> };
>create : <T extends { [s: string]: ViewStyle; }>(styles: T) => { [P in keyof T]: Brand<T[P]>; }
>s : string
>styles : T

const wrapped = create({ first: { view: 0, styleMedia: "???" } });
>wrapped : { first: Brand<{ view: number; styleMedia: string; }>; }
>create({ first: { view: 0, styleMedia: "???" } }) : { first: Brand<{ view: number; styleMedia: string; }>; }
>create : <T extends { [s: string]: ViewStyle; }>(styles: T) => { [P in keyof T]: Brand<T[P]>; }
>{ first: { view: 0, styleMedia: "???" } } : { first: { view: number; styleMedia: string; }; }
>first : { view: number; styleMedia: string; }
>{ view: 0, styleMedia: "???" } : { view: number; styleMedia: string; }
>view : number
>0 : 0
>styleMedia : string
>"???" : "???"

const vs: ViewStyle = wrapped.first // error, first is a branded number
>vs : ViewStyle
>wrapped.first : Brand<{ view: number; styleMedia: string; }>
>wrapped : { first: Brand<{ view: number; styleMedia: string; }>; }
>first : Brand<{ view: number; styleMedia: string; }>

